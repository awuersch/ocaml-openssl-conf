<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=utf-8" http-equiv="Content-Type">
<link rel="Start" href="index.html">
<link rel="Up" href="index.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Sslconf" rel="Chapter" href="Sslconf.html"><title>Sslconf</title>
</head>
<body>
<div class="navbar">&nbsp;<a class="up" href="index.html" title="Index">Up</a>
&nbsp;</div>
<h1>Module <a href="type_Sslconf.html">Sslconf</a></h1>

<pre><span class="keyword">module</span> Sslconf: <code class="code"><span class="keyword">sig</span></code> <a href="Sslconf.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info module top">
an OCaml version of Openssl's NCONF library
<p>

    <em>%%VERSION%% â€” <a href="%%PKG_HOMEPAGE%% ">homepage</a></em><br>
</div>
<hr width="100%">
<br>
Module <code class="code"><span class="constructor">Sslconf</span></code>: a parser for Openssl config files.<br>
<br>
Openssl config files are ubiquitous in books, in documentation,
    and in Stack Overflow answers.
<p>

    Openssl config file documentation:
    <a href=" https://www.openssl.org/docs/manmaster/man5/config.html"> config.html</a>
<p>

    The Openssl config file documentation is enough for most users, but it
    is not a complete specification.
<p>

    Definition of X509 certificates in Openssl is usually done by
    Openssl config files.
<p>

    This module reproduces the Openssl NCONF implementation.  
    Openssl NCONF is part of the Openssl crypto library (-libcrypto).
<p>

    This module attaches no semantics to the strings and stacks it
    returns. It is similar to Openssl NCONF in this way.
<p>

    Openssl attaches semantics to hash tables returned by Openssl
    NCONF, <em>via</em> commands such as <em>openssl x509</em> or <em>openssl ca</em>.
<p>

    This implementation uses standard OCaml hash tables and stacks.
    Some may view this as a weakness.
    Openssl's NCONF implementation draws on custom hash tables and
    stacks defined in Openssl's crypto library.
<p>

    Openssl code:
    <a href=" https://github.com/openssl/openssl/blob/master/include/openssl/conf.h"> conf.h</a>
    <a href=" https://github.com/openssl/openssl/blob/master/crypto/conf/conf_def.c"> conf_def.c</a>
    <a href=" https://github.com/openssl/openssl/blob/master/crypto/conf/conf_api.c"> conf_api.c</a>
    <a href=" https://github.com/openssl/openssl/blob/master/crypto/conf/conf_lib.c"> conf_lib.c</a>
    <a href=" https://github.com/openssl/openssl/blob/master/crypto/bio/bss_fd.c"> bss_fd.c</a><br>

<pre><span id="TYPEt"><span class="keyword">type</span> <code class="type"></code>t</span> </pre>
<div class="info ">
Sslconf type<br>
</div>


<pre><span id="VALcreate"><span class="keyword">val</span> create</span> : <code class="type">unit -> <a href="Sslconf.html#TYPEt">t</a></code></pre><div class="info ">
Initialize an Sslconf instance<br>
</div>

<pre><span id="VALnbits"><span class="keyword">val</span> nbits</span> : <code class="type">int option Pervasives.ref</code></pre><div class="info ">
<code class="code"><span class="constructor">FOR</span> <span class="constructor">TESTING</span> <span class="constructor">ONLY</span></code> Limits buffer allocated memory to a max bit length.<br>
</div>

<pre><code><span id="TYPEerror"><span class="keyword">type</span> <code class="type"></code>error</span> = </code></pre><table class="typetable">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTerror.Open"><span class="constructor">Open</span></span> <span class="keyword">of</span> <code class="type">string</code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTerror.Extend"><span class="constructor">Extend</span></span> <span class="keyword">of</span> <code class="type">string * int * int * int</code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTerror.Parse"><span class="constructor">Parse</span></span> <span class="keyword">of</span> <code class="type">string * int * int * string * string</code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
Open (msg):
    <ul>
<li>open failure message</li>
</ul>

    Extend (msg nbits max_length max_alloc):
    <ul>
<li>failure message;</li>
<li>number of bits allowed in buffer size;</li>
<li>requested new length of buffer;</li>
<li>allocation limit of buffer size.</li>
</ul>

    Parse (file lineno col proc msg):
    <ul>
<li>file name;</li>
<li>line number where error was seen;</li>
<li>column position where error was seen;</li>
<li>procedure name in which error was seen;</li>
<li>error message.</li>
</ul>
<br>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr></table>



<pre><span id="VALerror_to_string"><span class="keyword">val</span> error_to_string</span> : <code class="type"><a href="Sslconf.html#TYPEerror">error</a> -> string</code></pre><div class="info ">
<code class="code">error_to_string error</code> converts an error to a user-readable string.<br>
</div>

<pre><span id="VALconf_load_file"><span class="keyword">val</span> conf_load_file</span> : <code class="type"><a href="Sslconf.html#TYPEt">t</a> -> string -> (unit, <a href="Sslconf.html#TYPEerror">error</a>) Pervasives.result</code></pre><div class="info ">
<code class="code">conf_load_file conf filename</code> loads a file into a <a href="Sslconf.html#TYPEt"><code class="code"><span class="constructor">Sslconf</span>.t</code></a> instance.
    The error instance describes only the first failure found.
<p>

    Lines recognized by the parser are:
    <ul>
<li>comment lines, i.e.,
           <ul>
<li>empty, or all whitespace;</li>
<li>(Win32 only) a semicolon (<code class="code"><span class="string">';'</span></code>) before non-white-space; or</li>
<li>whitespace, then a hash char (<code class="code"><span class="string">'#'</span></code>), then arbitrary data;</li>
</ul>
</li>
<li>section lines, i.e.,
           <ul>
<li>a (<code class="code"><span class="string">"[&lt;section&gt;]"</span></code>) string inside square brackets; or</li>
</ul>
</li>
<li>value lines, i.e.,
           <ul>
<li>a (<code class="code"><span class="string">"&lt;name&gt; = &lt;value&gt;"</span></code>) assignment.</li>
</ul>
</li>
</ul>

<p>

    Openssl config file documentation:
    <a href=" https://www.openssl.org/docs/manmaster/man5/config.html"> config.html</a>
<p>

    The Openssl config file documentation is enough for most users, but it
    is not a complete specification.
<p>

    What follows is detail. It goes beyond what users want to see.
<p>

    <h1 id="1_DetailFirstPassLineContinuationChars">Detail First Pass - Line Continuation Chars</h1>
<p>

    If the parser sees an escape char (<code class="code"><span class="string">'\\'</span></code>) at the end of a line, it
    combines the line with the next line.
<p>

    The escape char may itself be escaped, in which case it loses its special
    meaning as a line continuation mark.
<p>

    <h2 id="2_BoundedReadsandContinuationChars">Bounded Reads and Continuation Chars</h2>
<p>

    The parser reads up to a newline, or to a maximum length if no newline
    is found. If no newline is found, the parser does another read, and so on
    until a newline is found or end of file is is detected.
<p>

    The maximum number of characters the parser reads in one read is 510.
    This number is dictated by a need for C code to put null bytes in a
    512 byte buffer.
<p>

    If the parser sees an escape char (<code class="code"><span class="string">'\\'</span></code>) at the end of a read, it will
    apply its continuation char logic. The logic applies even if a newline
    is not seen at the end. So, if the parser decides it has a continuation
    character, it will skip over it.
<p>

    This implementation imitates what the Openssl parser would do. It looks
    at the 510 byte mark for an escape char, and skips over it if found.
<p>

    <h2 id="2_Linenumbererrorreporting">Line number error reporting</h2>
<p>

    When there is an error, the line number reported is the line number in the
    file. This implementation also reports the column where an error is seen.
    Line numbers and columns reported are 1-based, so the first line is line 1
    and the first column is column 1.
<p>

    <h1 id="1_Commentlines">Comment lines</h1>
<p>

    A comment line is either an empty line, a line of all whitespace,
    or whitespace followed by a hash char followed by anything.
<p>

    Comments are not saved.
<p>

    In Win32 only, a line starting with a semicolon is also a comment.
<p>

    The end of a value line may have a comment.
    These comments start with a hash char.
    Any text up to end of line can follow the hash char.
<p>

    <h1 id="1_Sectionlines">Section lines</h1>
<p>

    A section line has a (<code class="code"><span class="string">"[&lt;section&gt;]"</span></code>) string surrounded by square brackets.
    After whitespace is trimmed from both ends, the string names
    a section.
<p>

    A section may contain alphanumerics, underscores, punctuation,
    or whitespace.
<p>

    Alphanumerics are any letter (from <code class="code"><span class="string">'a'</span></code> to <code class="code">z</code> or <code class="code"><span class="string">'A'</span></code> to <code class="code"><span class="string">'Z'</span></code>)
    or a number (from <code class="code"><span class="string">'0'</span></code> to <code class="code"><span class="string">'9'</span></code>).
<p>

    Underscores are one or more underscore ('_') characters.
<p>

    Punctuation is one or more of the following characters:
    (<code class="code"><span class="string">'!'</span></code>, <code class="code"><span class="string">'.'</span></code>, <code class="code"><span class="string">'%'</span></code>, <code class="code"><span class="string">'&amp;'</span></code>, <code class="code"><span class="string">'*'</span></code>, <code class="code"><span class="string">'+'</span></code>, <code class="code"><span class="string">';'</span></code>,
     <code class="code"><span class="string">'?'</span></code>, <code class="code"><span class="string">'@'</span></code>, <code class="code"><span class="string">'^'</span></code>, <code class="code"><span class="string">'~'</span></code>, <code class="code"><span class="string">'|'</span></code>, or <code class="code"><span class="string">'-'</span></code>).
<p>

    A section may also contain <em>escaped</em> characters.
    An escaped character immediately follows an escape (<code class="code"><span class="string">'\\'</span></code>) char.
    Any character can be an escaped character.
<p>

    If an escaped character is (<code class="code"><span class="string">'r'</span></code>, <code class="code"><span class="string">'n'</span></code>, <code class="code"><span class="string">'b'</span></code>, or <code class="code"><span class="string">'t'</span></code>), it
    is translated into a whitespace char (<code class="code"><span class="string">"\r"</span>, <span class="string">"\n"</span>, <span class="string">"\b"</span>, <span class="keyword">or</span> <span class="string">"\t"</span></code>).
    Otherwise, it is retained <em>as is</em>.
<p>

    Escape chars are stripped out from a section name. Escaped chars
    appear in section keys as if they were not escaped.
<p>

    The section in a section line becomes a default section
    for lines which follow.
    It remains the default until a next section line is read.
<p>

    <h1 id="1_Valuelines">Value lines</h1>
<p>

    A line with a a (<code class="code"><span class="string">"&lt;name&gt; = &lt;value&gt;"</span></code>) assignment.
    i.e., a name, an equal sign, and a value, is a value line.
    A value line assigns a value to a name.
<p>

    <h2 id="2_Names">Names</h2>
<p>

    Lexical rules for a name (qualified or unqualified) are more
    restrictive than for a section in a section line.
<p>

    Whitespace is trimmed from both ends of a name.
<p>

    A name may contain alphanumerics, underscores, and punctuation.
    A name may not contain whitespace.
<p>

    As with section names, escaped characters are allowed.
    An escaped character immediately follows an escape (<code class="code"><span class="string">'\\'</span></code>) char.
    Any character may be an escaped character.
<p>

    Unlike the case of section names, escape chars are not stripped.
    An escape char goes in the hash table as part of a name.
<p>

    A name can be qualified or unqualified. A qualified name splits
    into two parts, separated by a two-colon string (<code class="code"><span class="string">"::"</span></code>). The first
    part of a qualified name is the section; the second part is the
    name. An unqualified name belongs to the current default section.
<p>

    If the section of a qualified name is not in the hash table, a
    new entry for the section is added.
<p>

    <h2 id="2_Values">Values</h2>
<p>

    A value is a concatenated sequence of parts. It starts with the
    first non-whitespace character after the equal sign on a value line.
<p>

    A part is one of three kinds:
    <ul>
<li>wrapped by double or single quotes;</li>
<li>a name substitution; or</li>
<li>regular text.</li>
</ul>

<p>

    Whitespace is stripped from the start and end of a value. Hence,
    whitespace following the equal sign, and whitespace to the end of
    a line, or up to a comment hash char if present, is ignored.
    A value starts and ends with a non-whitespace value, unless its
    first or last value was escaped <em>via</em> an escape (<code class="code"><span class="string">'\\'</span></code>) char.
<p>

    <h3 id="3_Quotewrappedparts">Quote wrapped parts</h3>
<p>

    Unix and Cygwin use default quote wrapping.
<p>

    Default quote wrapped parts accept any character <em>as is</em>, and
    also allow quotes if preceded immediately by escape chars.
<p>

    Escape chars and
    the quotes which wrap quote surrounded parts
    are stripped.
<p>

    Win32 uses double quote wrapping.
<p>

    Double quote wrapped parts accept any character <em>as is</em>.
    Double quotes normally end a double quote wrapped string.
    However, if two double quotes appear next to each other,
    one of them is added, the other is stripped, and the double
    quote string continues.
<p>

    Double quotes which wrap double quote surrounded parts are
    stripped.
<p>

    <h3 id="3_Namesubstitution">Name substitution</h3>
<p>

    Name substitution starts with a (<code class="code"><span class="string">'$'</span></code>) character.
    The (<code class="code"><span class="string">'$'</span></code>) character should be followed by a name.
    The name may be optionally wrapped
    by parentheses (<code class="code"><span class="string">"()"</span></code>) or curly brackets (<code class="code"><span class="string">"{}"</span></code>).
    The <code class="code">subst</code> evaluator replaces
    the (<code class="code"><span class="string">'$'</span></code>), the optional wrapping, and the name
    with the value corresponding to the name and its section.
<p>

    If the section is not (<code class="code"><span class="string">"ENV"</span></code>),
    a value is found from a hashtable with section+name keys.
    If the section is (<code class="code"><span class="string">"ENV"</span></code>), 
    a value is found from the process environment.
<p>

    If substitution fails, the parser returns an error,
    It reports that no value could be found for the name.
<p>

    A name given for name substitution may only contain
    alphanumeric or underscore characters.
    It may not contain punctuation or whitespace,
    unless these are escaped <em>via</em> an escape (<code class="code"><span class="string">'\\'</span></code>) character.
    If an escaped character is in a name,
    its escape char is <em>retained</em>,
    along with the escaped character in the name.
<p>

    <h3 id="3_Regularvaluetextieunwrappedparts">Regular value text, i.e., unwrapped parts</h3>
<p>

    Regular text accepts any character other than
    single quotes,
    double quotes, or
    the (<code class="code"><span class="string">'$'</span></code>) substitution character.
<p>

    It may still have
    <ul>
<li>escaped characters; or</li>
<li>hash chars, for comments to end of line.</li>
</ul>

<p>

    <h4 id="4_Escapedcharsinregulartext">Escaped chars in regular text</h4>
<p>

    Regular text can have escaped characters.
    An escaped character immediately follows an escape (<code class="code"><span class="string">'\\'</span></code>) char.
<p>

    If an escaped character is (<code class="code"><span class="string">'r'</span></code>, <code class="code"><span class="string">'n'</span></code>, <code class="code"><span class="string">'b'</span></code>, or <code class="code"><span class="string">'t'</span></code>), it
    is translated into a whitespace char (<code class="code"><span class="string">"\r"</span>, <span class="string">"\n"</span>, <span class="string">"\b"</span>, <span class="keyword">or</span> <span class="string">"\t"</span></code>).
    If it is not one of these characters, it is retained <em>as is</em>.
<p>

    The special meanings of escaped characters are cancelled. For
    example, one can precede a double quote by an escape char, to
    cancel its usual meaning of starting a quote-wrapped part.
<p>

    Escape chars are stripped. They don't appear in hash table values.
    Escaped characters remain.
<p>

    <h4 id="4_Hashcharsinregulartextstartcommentstoendofline">Hash chars in regular text start comments to end of line</h4>
<p>

    An unescaped hash (<code class="code"><span class="string">'#'</span></code>) char starts a comment to end of line.
    Any data following the hash char, up to the end of a line, is ignored.
<p>

    <h4 id="4_Nonspecialcharsinregulartext">Non-special chars in regular text</h4>
<p>

    Characters not belonging to wrapped segments or name substitutions
    can be any character.
    For example, whitespace can occur in the middle of a value.<br>
</div>

<pre><span id="VALconf_get_string"><span class="keyword">val</span> conf_get_string</span> : <code class="type">?conf:<a href="Sslconf.html#TYPEt">t</a> -> ?section:string -> string -> string option</code></pre><div class="info ">
<code class="code">conf_get_string ?conf ?section name</code> gets an optional value from a name.
    A string option is returned.
    See Openssl <code class="code"><span class="constructor">NCONF_get_string</span>()</code>
    in <a href=" https://github.com/openssl/openssl/blob/master/crypto/conf/conf_lib.c"> conf_lib.c</a>.
    If a config instance is provided,
    its hash table with section+name keys is searched.
    If no config instance is provided, the process environment is searched.
    If a section is provided, then:
    <ul>
<li>if the section is <code class="code"><span class="string">"ENV"</span></code>, the process environment is searched.</li>
<li>else the section and name are made into a pair,
           and the pair is searched for in the hash table.</li>
</ul>

    If no section is provided, or the search in a provided section fails,
    then section "default" is used with the name.<br>
</div>

<pre><span id="TYPEsection_stack"><span class="keyword">type</span> <code class="type"></code>section_stack</span> = <code class="type">(string * string) Stack.t</code> </pre>


<pre><span id="VALconf_get_section"><span class="keyword">val</span> conf_get_section</span> : <code class="type"><a href="Sslconf.html#TYPEt">t</a> -> string -> <a href="Sslconf.html#TYPEsection_stack">section_stack</a> option</code></pre><div class="info ">
<code class="code">get_section conf section</code> gets an optional stack of name-value pairs.
    See Openssl function <code class="code"><span class="constructor">NCONF_get_section</span>()</code>
    in <a href=" https://github.com/openssl/openssl/blob/master/crypto/conf/conf_lib.c"> conf_lib.c</a>.
    A hash table with section keys in the config instance is searched
    for a section.
    If a stack is returned, and &lt;name&gt; is in a name-value pair on it, then
    <code class="code">conf_get_string conf section name</code> will get its most recent value.<br>
</div>

<pre><span id="VALsexp_of_stack"><span class="keyword">val</span> sexp_of_stack</span> : <code class="type"><a href="Sslconf.html#TYPEsection_stack">section_stack</a> -> Sexplib.Sexp.t</code></pre><div class="info ">
convert a config instance section stack to an s-expression<br>
</div>

<pre><span id="VALstack_of_sexp"><span class="keyword">val</span> stack_of_sexp</span> : <code class="type">Sexplib.Sexp.t -> <a href="Sslconf.html#TYPEsection_stack">section_stack</a></code></pre><div class="info ">
convert an s-expression to a config instance section stack<br>
</div>

<pre><span id="VALsexp_of_conf"><span class="keyword">val</span> sexp_of_conf</span> : <code class="type"><a href="Sslconf.html#TYPEt">t</a> -> Sexplib.Sexp.t</code></pre><div class="info ">
convert a config instance to an s-expression<br>
</div>

<pre><span id="VALconf_of_sexp"><span class="keyword">val</span> conf_of_sexp</span> : <code class="type">Sexplib.Sexp.t -> <a href="Sslconf.html#TYPEt">t</a></code></pre><div class="info ">
convert an s-expression to a config instance<br>
</div>

<pre><span class="keyword">module</span> <a href="Sslconf.Buf.html">Buf</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Sslconf.Buf.html">..</a> <code class="code"><span class="keyword">end</span></code></pre>
<pre><span class="keyword">module</span> <a href="Sslconf.Bio.html">Bio</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Sslconf.Bio.html">..</a> <code class="code"><span class="keyword">end</span></code></pre></body></html>