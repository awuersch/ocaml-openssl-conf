<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=utf-8" http-equiv="Content-Type">
<link rel="Start" href="index.html">
<link rel="next" href="Sslconf.Bio.html">
<link rel="Up" href="Sslconf.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Sslconf" rel="Chapter" href="Sslconf.html">
<link title="Bio" rel="Chapter" href="Bio.html">
<link title="Buf" rel="Chapter" href="Buf.html"><title>Sslconf.Buf</title>
</head>
<body>
<div class="navbar">&nbsp;<a class="up" href="Sslconf.html" title="Sslconf">Up</a>
&nbsp;<a class="post" href="Sslconf.Bio.html" title="Sslconf.Bio">Next</a>
</div>
<h1>Module <a href="type_Sslconf.Buf.html">Sslconf.Buf</a></h1>

<pre><span class="keyword">module</span> Buf: <code class="code"><span class="keyword">sig</span></code> <a href="Sslconf.Buf.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><hr width="100%">
<br>
Sslconf buffer.<br>
<br>
This implements Openssl's buffer allocation policy in an OCaml runtime.
<p>

      <ul>
<li>Per-buffer memory allocation is limited to 2**<code class="code">nbits</code>-1.</li>
<li>A buffer has a desired length, which is null byte initialized.</li>
<li>Buffer memory allocation is 4/3 times desired length.</li>
</ul>

<p>

      from Openssl:
      <a href=" https://github.com/openssl/openssl/blob/master/include/openssl/buffer.h"> buffer.h</a>
      <a href=" https://github.com/openssl/openssl/blob/master/crypto/buffer/buffer.c"> buffer.c</a><br>
<br>
An Sslconf buffer supports an underlying <code class="code"><span class="constructor">Bytes</span>.t</code> buffer.
      <code class="code">empty nbits</code> is the constructor.
      Max allocated size is 2**<code class="code">nbits</code>-1 bytes.
      A good default <code class="code">nbits</code> value is 31.
      <code class="code">length</code> bytes are expected, These bytes are initialized to a null value.
      Dynamic allocated size is (floor((length + 3) / 3) * 4) bytes.<br>

<pre><span id="TYPEt"><span class="keyword">type</span> <code class="type"></code>t</span> </pre>
<div class="info ">
Buffer type.<br>
</div>


<pre><span id="VALempty"><span class="keyword">val</span> empty</span> : <code class="type">int -> <a href="Sslconf.Buf.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">empty nbits</code> creates an empty buffer.<br>
</div>

<pre><span id="VALdata"><span class="keyword">val</span> data</span> : <code class="type"><a href="Sslconf.Buf.html#TYPEt">t</a> -> Bytes.t</code></pre><div class="info ">
<code class="code">data buf</code> returns the underlying <code class="code"><span class="constructor">Bytes</span>.t</code> buffer.<br>
</div>

<pre><span id="VALextend"><span class="keyword">val</span> extend</span> : <code class="type"><a href="Sslconf.Buf.html#TYPEt">t</a> -><br>       int -> (<a href="Sslconf.Buf.html#TYPEt">t</a>, string * int * int * int) Pervasives.result</code></pre><div class="info ">
<code class="code">extend buf length</code> extends <code class="code">buf</code> to support <code class="code">length</code> bytes.
      <code class="code"><span class="constructor">Ok</span> buf</code> or <code class="code"><span class="constructor">Error</span> (msg length nbits allocation_limit)</code> is returned.
      New bytes up to <code class="code"><span class="constructor">Bytes</span>.length (<span class="constructor">Buf</span>.data buf)</code> are initialized
      to null. An error occurs, and no allocation is done, if <code class="code">length</code>
      would cause an allocation greater than buffer max allocated size.<br>
</div>
</body></html>